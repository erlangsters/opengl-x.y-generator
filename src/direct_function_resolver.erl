%%
%% This file is part of the OpenGL binding generator for the BEAM.
%%
%% It does this and that...
%%
-module(direct_function_resolver).
-export([resolve/4]).

resolve(Functions, EnumTypes, BitfieldTypes, EnumToConstantMap) ->
    % Resolving a function consists of augmenting the existing "function data"
    % with more data.
    maps:fold(fun(Name, Data0, ResolvedFunctions) ->
        ResolvedFunctionData = resolve_function(
            Name,
            Data0,
            EnumTypes,
            BitfieldTypes,
            EnumToConstantMap
        ),
        Data1 = maps:merge(Data0, ResolvedFunctionData),
        maps:put(Name,  Data1, ResolvedFunctions)
    end, #{}, Functions).

resolve_function(
    _FunctionName,
    FunctionData,
    EnumTypes,
    BitfieldTypes,
    EnumToConstantMap
) ->
    % There's never extra types generated by a direct function (it's only used
    % to combine multiple valid values commonly found in "indirect" functions).
    ExtraType = undefined,

    % We compute all data to generate the "-specs" attribute in the ".erl"
    % module.
    {SpecsParams, SpecsReturn} =
        function_resolver_common:resolve_function_specs(FunctionData),

    % The number of parameters is the arity of the function.
    FunctionArity = length(SpecsParams),

    % In a "direct" function, there is always one function clause which calls
    % the associated OpenGL function (its "NIF version"). It never makes use of
    % guards.
    FunctionClause = #{
        params => resolve_function_clause_params(
            maps:get(params_specs, FunctionData),
            EnumTypes,
            BitfieldTypes,
            EnumToConstantMap
        ),
        guards => [],
        raw_function => maps:get(gl_command, FunctionData)
    },

    % Since it's a direct mapping, there is only one NIF function.
    NifName = maps:get(gl_command, FunctionData),
    {NifParams, NifReturn} = function_resolver_common:resolve_nif_function(
        maps:get(params_specs, FunctionData),
        maps:get(return_specs, FunctionData)
    ),
    NifArity = length(NifParams),
    
    NifFunctions = #{
        NifName => #{
            arity => NifArity,
            params => NifParams,
            return => NifReturn
        }
    },

    #{
        extra_type => ExtraType,
        specs_params => SpecsParams,
        specs_return => SpecsReturn,
        function_arity => FunctionArity,
        function_clauses => [FunctionClause],
        nif_functions => NifFunctions
    }.

transform_rule_gl_enum_to_uint(EnumGroup, EnumTypes, EnumToConstantMap) ->
    % We instruct the module generator to transform the atom to an integer
    % before it reaches the NIF level. For this, it needs a map that translates
    % the possible atom values to the OpenGL constant names.
    EnumValues = maps:get(
        opengl_gen:erlangify_enum_group_name(EnumGroup),
        EnumTypes
    ),
    TransformMap = lists:map(fun(EnumValue) ->
        ConstantValue = maps:get(EnumValue, EnumToConstantMap),
        {EnumValue, ConstantValue}
    end, EnumValues),
    {gl_enum_to_uint, TransformMap}.

transform_rule_gl_bitfield_to_uint(EnumGroup, EnumTypes, EnumToConstantMap) ->
    EnumValues = maps:get(
        opengl_gen:erlangify_enum_group_name(EnumGroup),
        EnumTypes
    ),
    TransformMap = lists:map(fun(EnumValue) ->
        ConstantValue = maps:get(EnumValue, EnumToConstantMap),
        {EnumValue, ConstantValue}
    end, EnumValues),
    {gl_bitfield_to_uint, TransformMap}.

resolve_function_clause_param({in, ParamName, gl_bool}, _Data) ->
    % We let the NIF handle the conversation from atom to GLboolean
    % and therefore we pass it down to the NIF function as-is.
    {ParamName, do_nothing};
resolve_function_clause_param({in, ParamName, gl_int}, _Data) ->
    % Pass it down as-is (the NIF function will convert it).
    {ParamName, do_nothing};
% resolve_function_clause_param({in, ParamName, gl_int64}, _Data) -> % XXX: is needed ?
%     % Pass it down as-is (the NIF function will convert it).
%     {ParamName, do_nothing};
resolve_function_clause_param({in, ParamName, gl_uint}, _Data) ->
    % Pass it down as-is (the NIF function will convert it).
    {ParamName, do_nothing};
resolve_function_clause_param({in, ParamName, gl_uint64}, _Data) ->
    % Pass it down as-is (the NIF function will convert it).
    {ParamName, do_nothing};
resolve_function_clause_param({in, ParamName, gl_float}, _Data) ->
    % Pass it down as-is (the NIF function will convert it).
    {ParamName, do_nothing};
resolve_function_clause_param({in, ParamName, gl_double}, _Data) ->
    % Pass it down as-is (the NIF function will convert it).
    {ParamName, do_nothing};

resolve_function_clause_param({in, ParamName, {gl_string, char}}, _Data) ->
    % xxx
    {ParamName, do_nothing};




resolve_function_clause_param({in, ParamName, gl_sizei}, _Data) ->
    % Pass it down as-is (the NIF function will convert it).
    {ParamName, do_nothing};

resolve_function_clause_param({in, ParamName, gl_intptr}, _Data) ->
    % Pass it down as-is (the NIF function will convert it).
    {ParamName, do_nothing};
resolve_function_clause_param({in, ParamName, gl_sizeiptr}, _Data) ->
    % Pass it down as-is (the NIF function will convert it).
    {ParamName, do_nothing};

resolve_function_clause_param({in, ParamName, gl_binary_or_null}, _Data) ->
    % Pass it down as-is (the NIF function will convert it).
    % Example: glBufferData().
    {ParamName, do_nothing};
resolve_function_clause_param({in, ParamName, gl_offset}, _Data) ->
    % Pass it down as-is (the NIF function will convert it).
    % Example: glVertexAttribPointer().
    {ParamName, do_nothing};


resolve_function_clause_param({in, ParamName, {gl_enum, EnumGroup}}, Data) ->
    % We pre-process the atom and convert to its integer value.
    {EnumTypes, _, EnumToConstantMap} = Data,
    {ParamName, transform_rule_gl_enum_to_uint(EnumGroup, EnumTypes, EnumToConstantMap)};
resolve_function_clause_param({in, ParamName, {gl_bitfield, EnumGroup}}, Data) ->
    % We pre-process the list of atoms and convert to its integer
    % value.
    {_, BitfieldTypes, EnumToConstantMap} = Data,
    {ParamName, transform_rule_gl_bitfield_to_uint(EnumGroup, BitfieldTypes, EnumToConstantMap)};
resolve_function_clause_param({in, ParamName, gl_binary}, _Data) ->
    % Pass it down as-is (the Erlang bin will be read in the NIF,
    % read-only way).
    {ParamName, do_nothing};

resolve_function_clause_param({out, _ParamName, gl_string}, _Data) ->
    % It generates a parameter to specify the size of the binary to be
    % allocated. 
    % Example: `glGetShaderSource`, `glGetProgramInfoLog()`
    SizeParamName = "StringSize",
    {SizeParamName, do_nothing};

resolve_function_clause_param({out, _ParamName, {gl_binary, {implicit, SizeParamName}}}, _Data) ->
    % It generates a parameter to specify the size of the binary to be
    % allocated. Example: glReadPixels().
    {SizeParamName, do_nothing};
resolve_function_clause_param({out, _ParamName, {gl_binary, {explicit, SizeParamName}}}, _Data) ->
    % Same as an "implicit" binary. Example: glReadnPixels().
    {SizeParamName, do_nothing};
resolve_function_clause_param({in, ParamName, {gl_object, _Name}}, Data) ->
    % An "OpenGL object" is nothing but a GLuint.
    resolve_function_clause_param({in, ParamName, gl_uint}, Data);
resolve_function_clause_param({in, ParamName, {list, {gl_object, _Name}}}, _Data) ->
    % We pre-process the list of integers and make a binary out of it
    % before passing it to the NIF function.
    % Example: glDeleteTextures() takes a list of textures.
    {ParamName, list_gl_objects_to_binary};

% resolve_function_clause_param({out, _ParamName, {list, {gl_object, _Name}}}, _Data) ->
resolve_function_clause_param({out, _ParamName, {{list, _}, _}}, _Data) ->
    % Any "out" parameter that is a list of simple values creates a blabla
    %  xxx: write 
    % Example: glGenTextures() takes a list of textures.
    {"N", do_nothing};
resolve_function_clause_param({in, ParamName, list_gl_strings}, _Data) ->
    % We normalize the list so it's only a list of binaries.
    % Example: glShaderSource()
    {ParamName, normalize_list_strings_or_binary}.


% resolve_function_clause_param({out, _, _}, _Data) ->
%     % Any simple "out" paramater (GLboolean, GLint, etc.) does not correspond 
%     % to any parameter. (The NIF function will create the variable, the OpenGL
%     % function will write to it, and the NIF function will return it).
%     skip.

resolve_function_clause_params(
    ParamsSpecs,
    EnumTypes,
    BitfieldTypes,
    EnumToConstantMap
) ->
    % Data needed to resolve the parameters of a function clause.
    Data = {EnumTypes, BitfieldTypes, EnumToConstantMap},
    lists:foldl(fun(ParamSpecs, Acc) ->
        case resolve_function_clause_param(ParamSpecs, Data) of
            skip ->
                Acc;
            R ->
                Acc ++ [R]
        end
    end, [], ParamsSpecs).
